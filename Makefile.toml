extend = "./crates/wdk-build/rust-driver-makefile.toml"

[config]
min_version = "0.37.16"
additional_profiles = ["all-default-tasks"]

[env]
CARGO_MAKE_SKIP_SLOW_SECONDARY_FLOWS = false
CARGO_MAKE_CARGO_BUILD_TEST_FLAGS = "${CARGO_MAKE_CARGO_ALL_FEATURES}"
CARGO_MAKE_CLIPPY_ARGS = "--all-targets --all-features"
CARGO_MAKE_RUST_DEFAULT_TOOLCHAIN = "stable"
RUSTFLAGS = "-D warnings"
RUSTDOCFLAGS = "-D warnings"

[tasks.wdk-pre-commit-flow]
description = "Run pre-commit tasks and checks"
category = "Development"
workspace = false
dependencies = [
  "format-flow",
  "format-toml-conditioned-flow",
  "build",
  "package-driver-workspace-flow",
  "test-flow",
  "clippy-flow",
  "audit-flow",
  "unused-dependencies-flow",
  "docs",
  "nightly-test-flow",
  "nightly-clippy-flow",
  "nightly-docs",
  "beta-test-flow",
  "beta-clippy-flow",
  "beta-docs",
]

[tasks.format]
toolchain = "nightly"

[tasks.package-driver-workspace-flow]
# by forking, a new cargo make invocation starts and by default detects it is a workspace and runs the package-driver task for each member crate
run_task = { name = "package-driver-flow", fork = true }

[tasks.pre-test]
# macrotest and trybuild tests will fail when switching between nightly and stable toolchains due to trybuild/macrotest caching artifacts built with the other toolchain. Deleting the tests directory is enough to purge all test artifacts created by trybuild/macrotest.
script = '''
#!@duckscript
success = rm -r ${CARGO_MAKE_CRATE_CUSTOM_TRIPLE_TARGET_DIRECTORY}/tests
assert ${success} "Failed to delete tests directory"
'''

[tasks.test]
install_crate = { crate_name = "cargo-expand", binary = "cargo", test_arg = [
  "expand",
  "--version",
], version = "1.0.85" }

[tasks.audit]
args = ["audit", "--deny", "warnings"]

[tasks.unused-dependencies]
workspace = false
condition = { env_true = ["CARGO_MAKE_CRATE_HAS_DEPENDENCIES"] }
args = ["machete", "--skip-target-dir"]

[tasks.nightly-test-flow]
extend = "test-flow"
dependencies = ["pre-nightly-test", "nightly-test", "post-nightly-test"]

[tasks.pre-nightly-test]
alias = "pre-test"

[tasks.nightly-test]
extend = "test"
toolchain = "nightly"

[tasks.post-nightly-test]
extend = "post-test"

[tasks.nightly-clippy-flow]
extend = "clippy-flow"
dependencies = [
  "pre-nightly-clippy",
  "nightly-clippy-router",
  "post-nightly-clippy",
]

[tasks.pre-nightly-clippy]
extend = "pre-clippy"
# Proc-macro crates fail to trigger recompilation when switching toolchains due to bug in rustc resulting in "found invalid metadata files for crate" errors.
run_task = "clean"

[tasks.nightly-clippy-router]
extend = "clippy-router"
env = { CARGO_MAKE_CLIPPY_ARGS = "--features nightly ${CARGO_MAKE_CLIPPY_ARGS}", CARGO_MAKE_RUST_DEFAULT_TOOLCHAIN = "nightly" }

[tasks.post-nightly-clippy]
extend = "post-clippy"
env = { CARGO_MAKE_RUST_DEFAULT_TOOLCHAIN = "${CARGO_MAKE_RUST_DEFAULT_TOOLCHAIN}" }

[tasks.nightly-docs]
extend = "docs"
toolchain = "nightly"
args = ["doc", "--no-deps", "--features", "nightly"]

[tasks.beta-test-flow]
extend = "test-flow"
dependencies = ["pre-beta-test", "beta-test", "post-beta-test"]

[tasks.pre-beta-test]
alias = "pre-test"

[tasks.beta-test]
extend = "test"
toolchain = "beta"

[tasks.post-beta-test]
alias = "post-test"

[tasks.beta-clippy-flow]
extend = "clippy-flow"
dependencies = ["pre-beta-clippy", "beta-clippy-router", "post-beta-clippy"]

[tasks.pre-beta-clippy]
extend = "pre-clippy"
# Proc-macro crates fail to trigger recompilation when switching toolchains due to bug in rustc resulting in "found invalid metadata files for crate" errors.
run_task = "clean"

[tasks.beta-clippy-router]
extend = "clippy-router"
env = { CARGO_MAKE_RUST_DEFAULT_TOOLCHAIN = "beta" }

[tasks.post-beta-clippy]
extend = "post-clippy"
env = { CARGO_MAKE_RUST_DEFAULT_TOOLCHAIN = "${CARGO_MAKE_RUST_DEFAULT_TOOLCHAIN}" }

[tasks.beta-docs]
extend = "docs"
toolchain = "beta"

[tasks.generate-wdk-sys-diff]
workspace = false
dependencies = ["build"]
script_runner = "@rust"
script_runner_args = [
  "--base-path",
  "${CARGO_MAKE_CURRENT_TASK_INITIAL_MAKEFILE_DIRECTORY}",
]
script = '''
//! ```cargo
//! [dependencies]
//! # test-stubs feature is required to provide dummy stubs for expected WDK symobls
//! wdk-sys = { path = "./crates/wdk-sys", features = ["test-stubs"] }
//! wdk-build = { path = "./crates/wdk-build" }
//! git2 = "0.18"
//! uu_cp = "0.0.24"
//! similar = { version = "2.4, features = ["unicode"] }
//! ```
#![allow(unused_doc_comments)]

use std::io::prelude::*;

let repo_root_path = std::path::PathBuf::from(
    std::env::var("CARGO_MAKE_CURRENT_TASK_INITIAL_MAKEFILE_DIRECTORY").expect(
        "CARGO_MAKE_CURRENT_TASK_INITIAL_MAKEFILE_DIRECTORY should be set by cargo-make",
    ),
);
let output_folder_path = wdk_build::cargo_make::get_wdk_build_output_directory();

// Create wdk-sys-diff directory
let wdk_sys_diff_folder = output_folder_path.join("wdk-sys-diff");
if !wdk_sys_diff_folder.exists() {
    std::fs::create_dir(&wdk_sys_diff_folder)
        .expect("wdk-sys-diff folder should be created successfully");
}

// Create local-copy sub-directory
let local_copy_folder = wdk_sys_diff_folder.join("local-copy");
if local_copy_folder.exists() {
    std::fs::remove_dir_all(&local_copy_folder)
        .expect("local-copy folder should succeed to be be removed");
}

// Copy local copy of windows-drivers-rs into local-copy sub-directory
// This uses a temporary directory as an intermediate to avoid recursively copying the local-copy folder
let tmp_dir = repo_root_path.join("../temp-wdr-copy");
if tmp_dir.exists() {
    std::fs::remove_dir_all(&tmp_dir)
        .expect("temp-wdr-copy temporary folder should succeed to be be removed");
}
uu_cp::copy(
    &[repo_root_path],
    &tmp_dir,
    &uu_cp::Options {
        attributes: uu_cp::Attributes::NONE, 
        attributes_only: false,
        copy_contents: false,
        cli_dereference: false,
        copy_mode: uu_cp::CopyMode::Copy,
        dereference: true,
        one_file_system: false,
        parents: false,
        update: uu_cp::UpdateMode::ReplaceAll,
        debug: false,
        verbose: false,
        strip_trailing_slashes: false,
        reflink_mode: uu_cp::ReflinkMode::Never,
        sparse_mode: uu_cp::SparseMode::Auto,
        backup: uu_cp::BackupMode::NoBackup,
        backup_suffix: "~".to_owned(),
        no_target_dir: false,
        overwrite: uu_cp::OverwriteMode::Clobber(uu_cp::ClobberMode::Standard),
        recursive: true,
        target_dir: None,
        progress_bar: false
    },
).expect("Copying repo to local-copy folder should succeed");
std::fs::rename(&tmp_dir, &local_copy_folder)
    .expect("temp-wdr-copy folder should successfully be moved to local-copy folder");

// Inject OUT_DIR variable into local-copy
let wdk_sys_lib_rs_file = local_copy_folder.join("crates/wdk-sys/src/lib.rs");
{
    let mut file = std::fs::File::options().append(true).open(wdk_sys_lib_rs_file)
        .expect("wdk-sys lib.rs should be able to be opened for appending");
    file.write_all(
        b"/// path to the output directory containing all the bindgen-generated modules\n\
          pub const OUT_DIR: &str = env!(\"OUT_DIR\");\n")
        .expect("appending to wdk-sys lib.rs should succeed");
}

// Get OUT_DIR of local-copy (rust-script will take care of compiling wdk-sys with the injected variable)
println!("Building local-copy:");
let mut process_handle = std::process::Command::new("rust-script")
    .args([
        "--cargo-output",
        "--dep",
        r#"wdk-sys={path="./crates/wdk-sys",features = ["test-stubs"]}"#,
        "--expr",
        "wdk_sys::OUT_DIR",
    ])
    .current_dir(&local_copy_folder)
    .stdout(std::process::Stdio::piped())
    .spawn()
    .expect("rust-script should succeed to start executing expression to get local-copy's wdk_sys::OUT_DIR");
let mut stdout = process_handle.stdout.take().expect("rust-script should have valid stdout handle");
if !process_handle.wait().expect("rust-script process handle should sucessfully be waited on").success() {
    panic!("rust-script failed to execute expression to get local-copy's wdk_sys::OUT_DIR");
}
let mut buffer = std::vec::Vec::<u8>::new();
stdout.read_to_end(&mut buffer).expect("stdout should be able to be read into buffer successfully");
let local_copy_out_dir = std::str::from_utf8(&buffer).expect("stdout should be valid utf8");

// Create latest-main sub-directory
let latest_main_folder = wdk_sys_diff_folder.join("latest-main");
if latest_main_folder.exists() {
    std::fs::remove_dir_all(&latest_main_folder)
        .expect("latest-main folder should succeed to be be removed");
}
std::fs::create_dir(&latest_main_folder)
    .expect("latest_main_folder folder should be created successfully");

// Clone latest main branch of windows-drivers-rs into latest-main sub-directory
let _ = git2::Repository::clone(
    // "https://github.com/microsoft/windows-drivers-rs.git",
    "https://github.com/wmmc88/windows-drivers-rs.git",
    &latest_main_folder,
)
.expect("Failed to clone latest main branch of windows-drivers-rs");

// Inject OUT_DIR variable into latest-main
let wdk_sys_lib_rs_file = latest_main_folder.join("crates/wdk-sys/src/lib.rs");
{
    let mut file = std::fs::File::options().append(true).open(wdk_sys_lib_rs_file)
        .expect("wdk-sys lib.rs should be able to be opened for appending");
    file.write_all(
        b"/// path to the output directory containing all the bindgen-generated modules\n\
          pub const OUT_DIR: &str = env!(\"OUT_DIR\");\n")
        .expect("appending to wdk-sys lib.rs should succeed");
}

// Get OUT_DIR of latest-main (rust-script will take care of compiling wdk-sys with the injected variable)
println!("Building latest-main:");
let mut process_handle = std::process::Command::new("rust-script")
    .args([
        "--cargo-output",
        "--dep",
        r#"wdk-sys={path="./crates/wdk-sys",features = ["test-stubs"]}"#,
        "--expr",
        "wdk_sys::OUT_DIR",
    ])
    .current_dir(&latest_main_folder)
    .stdout(std::process::Stdio::piped())
    .spawn()
    .expect("rust-script should succeed to start executing expression to get latest-main's wdk_sys::OUT_DIR");
let mut stdout = process_handle.stdout.take().expect("rust-script should have valid stdout handle");
if !process_handle.wait().expect("rust-script process handle should sucessfully be waited on").success() {
    panic!("rust-script failed to execute expression to get latest-main's wdk_sys::OUT_DIR");
}
let mut buffer = std::vec::Vec::<u8>::new();
stdout.read_to_end(&mut buffer).expect("stdout should be able to be read into buffer successfully");
let latest_main_out_dir = std::str::from_utf8(&buffer).expect("stdout should be valid utf8");

// TODO use metadata based approach instead of injecting OUT_DIR + do error handling for cargo check function

// # diff out-dirs
println!("{latest_main_out_dir}");
println!("{local_copy_out_dir}");



similar::TextDiff::configure()
            .algorithm(Algorithm::Patience)
            .diff_lines(OLD, NEW)
            .unified_diff()
'''
